
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSPy Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/leader-line-new@1.1.9/leader-line.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Fira+Code&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --text-color: #f8fafc;
            --accent-color: #38bdf8;
            --match-color: rgba(56, 189, 248, 0.2);
            --match-border: #38bdf8;
            --header-bg: #1e293b;
            --selection-bg: rgba(255, 255, 255, 0.1);
        }

        /* Overlap colors - distinct hues per group slot */
        .overlap-0 { background: rgba(56, 189, 248, 0.25); border-bottom-color: #38bdf8; }
        .overlap-1 { background: rgba(251, 146, 60, 0.25); border-bottom-color: #fb923c; }
        .overlap-2 { background: rgba(167, 139, 250, 0.25); border-bottom-color: #a78bfa; }
        .overlap-3 { background: rgba(74, 222, 128, 0.25); border-bottom-color: #4ade80; }
        .overlap-4 { background: rgba(251, 191, 36, 0.25); border-bottom-color: #fbbf24; }
        .overlap-5 { background: rgba(248, 113, 113, 0.25); border-bottom-color: #f87171; }
        .overlap-multi {
            background: repeating-linear-gradient(
                45deg,
                rgba(56, 189, 248, 0.2),
                rgba(56, 189, 248, 0.2) 3px,
                rgba(251, 146, 60, 0.2) 3px,
                rgba(251, 146, 60, 0.2) 6px
            );
            border-bottom: 2px dashed #fb923c;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background: var(--header-bg);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
            z-index: 100;
        }

        h1 { margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--accent-color); }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #334155;
            color: white;
            border: 1px solid #475569;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .btn:hover { background: #475569; }
        .btn.primary { background: var(--accent-color); color: #0f172a; border-color: var(--accent-color); font-weight: 600; }
        .btn.danger { background: #ef4444; border-color: #b91c1c; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 40px;
            overflow: hidden;
            position: relative;
        }

        .file-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--panel-bg);
            border-radius: 12px;
            border: 1px solid #334155;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            padding: 10px 20px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
            font-size: 0.9rem;
            font-weight: 600;
            color: #94a3b8;
            display: flex;
            justify-content: space-between;
        }

        .code-view {
            flex: 1;
            overflow: auto;
            padding: 20px;
            position: relative;
            counter-reset: line;
        }

        .code-line {
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            position: relative;
            padding-left: 0;
            min-height: 1.6em;
        }

        .code-line:hover {
            background: rgba(255,255,255,0.02);
        }

        .match-span {
            border-bottom: 2px solid var(--match-border);
            border-radius: 2px;
            cursor: pointer;
            padding: 1px 0;
            transition: background 0.2s;
        }

        .match-span:hover, .match-span.highlighted {
            filter: brightness(1.6);
            box-shadow: 0 0 8px currentColor;
        }

        /* Context Menu */
        #context-menu {
            position: absolute;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        /* Tooltip */
        #tooltip {
            position: fixed;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 12px 16px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #f8fafc;
            z-index: 1000;
            max-width: 450px;
            display: none;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            line-height: 1.5;
        }

        .badge {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-left: 12px;
            font-weight: 400;
        }

        /* Helper for text selection */
        ::selection {
            background: rgba(56, 189, 248, 0.3);
        }
    </style>
</head>
<body>
    <header>
        <h1>DSPy Visualizer: Match: 15_mipro_optimizer.py vs 15_prompt+response.txt <span class="badge" id="match-count"></span></h1>
        <div class="controls">
            <button class="btn" onclick="toggleAll()">Toggle All Arrows</button>
        </div>
    </header>

    <div class="main-container">
        <div class="file-panel">
            <div class="panel-header">15_mipro_optimizer.py</div>
            <div class="code-view" id="file1-container"></div>
        </div>

        <div class="file-panel">
            <div class="panel-header">15_prompt+response.txt</div>
            <div class="code-view" id="file2-container"></div>
        </div>
    </div>

    <!-- Context Menu for Match Actions -->
    <div id="context-menu">
        <button class="btn danger" onclick="deleteGroup(currentContextGroupId)">Delete Mapping</button>
    </div>

    <!-- Tooltip for mapping details -->
    <div id="tooltip"></div>

    <script>
        // Data injected from Python
        let groups = [{"Group_ID": "0", "File1_Pos": "15:8", "File1_Length": 17, "File2_Positions": [{"pos": "23:9", "length": 115}], "Label": "Class Docstring", "Description": "\"Analyze the sentiment of a given text and provide a brief explanation.\" becomes task instructions"}, {"Group_ID": "1", "File1_Pos": "16:5", "File1_Length": 4, "File2_Positions": [{"pos": "4:5", "length": 4}, {"pos": "11:7", "length": 4}], "Label": "Field Name: text", "Description": "\"text\" becomes text"}, {"Group_ID": "2", "File1_Pos": "15:49", "File1_Length": 19, "File2_Positions": [{"pos": "4:18", "length": 19}], "Label": "Field Description: text", "Description": "\"the text to analyze\" becomes input field description"}, {"Group_ID": "3", "File1_Pos": "17:5", "File1_Length": 9, "File2_Positions": [{"pos": "7:5", "length": 9}, {"pos": "15:7", "length": 9}, {"pos": "53:108", "length": 9}], "Label": "Field Name: sentiment", "Description": "\"sentiment\" becomes sentiment"}, {"Group_ID": "4", "File1_Pos": "17:40", "File1_Length": 47, "File2_Positions": [{"pos": "7:23", "length": 47}], "Label": "Field Description: sentiment", "Description": "\"sentiment label: positive, negative, or neutral\" becomes sentiment field description"}, {"Group_ID": "5", "File1_Pos": "18:5", "File1_Length": 10, "File2_Positions": [{"pos": "8:5", "length": 10}, {"pos": "17:7", "length": 10}, {"pos": "53:138", "length": 10}], "Label": "Field Name: confidence", "Description": "\"confidence\" becomes confidence"}, {"Group_ID": "6", "File1_Pos": "17:65", "File1_Length": 34, "File2_Positions": [{"pos": "14:44", "length": 34}], "Label": "Field Description: confidence", "Description": "\"confidence level from 0 to 1\" becomes confidence field description"}, {"Group_ID": "7", "File1_Pos": "19:5", "File1_Length": 11, "File2_Positions": [{"pos": "9:5", "length": 11}, {"pos": "19:7", "length": 11}, {"pos": "53:169", "length": 11}], "Label": "Field Name: explanation", "Description": "\"confidence\" becomes explanation"}, {"Group_ID": "8", "File1_Pos": "19:42", "File1_Length": 34, "File2_Positions": [{"pos": "9:25", "length": 34}], "Label": "Field Description: explanation", "Description": "\"brief explanation of the sentiment\" becomes explanation field description"}, {"Group_ID": "9", "File1_Pos": "54:19", "File1_Length": 80, "File2_Positions": [{"pos": "39:1", "length": 80}], "Label": "Training Example 1", "Description": "\"I absolutely love this product! It works perfectly and exceeded my expectations.\" from trainset[0] used as demonstration"}, {"Group_ID": "10", "File1_Pos": "60:19", "File1_Length": 53, "File2_Positions": [{"pos": "26:1", "length": 53}], "Label": "Training Example 2", "Description": "\"This movie was terrible. I wasted 2 hours of my life.\" from trainset[1] used as demonstration"}, {"Group_ID": "11", "File1_Pos": "124:10", "File1_Length": 27, "File2_Positions": [{"pos": "52:1", "length": 27}], "Label": "Test Input 3", "Description": "\"It's raining outside today.\" inserted as user message"}];
        const file1Lines = ["", "import dspy", "import sys", "import os", "", "# Add parent dir to path to import utils", "sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))", "from utils.response_saver import save_response", "", "# Configure", "lm = dspy.LM('ollama/gemma3:1b', api_base='http://localhost:11434')", "dspy.configure(lm=lm)", "", "class SentimentAnalysis(dspy.Signature):", "    \"\"\"Process the input\"\"\"", "    text = dspy.InputField(desc=\"the text to analyze\")", "    sentiment = dspy.OutputField(desc=\"sentiment label: positive, negative, or neutral\")", "    confidence = dspy.OutputField(desc=\"confidence level from 0 to 1\")", "    explanation = dspy.OutputField(desc=\"brief explanation of the sentiment\")", "", "# Define a DSPy Module (required for optimization)", "class SentimentModule(dspy.Module):", "    def __init__(self):", "        super().__init__()", "        self.predictor = dspy.ChainOfThought(SentimentAnalysis)", "", "    def forward(self, text):", "        return self.predictor(text=text)", "", "# Metric function: checks if sentiment prediction is reasonable", "def sentiment_accuracy(example, prediction, trace=None):", "    \"\"\"", "    Simple metric: check if predicted sentiment matches expected and confidence is non-zero.", "    In real scenarios, this would be more sophisticated.", "    \"\"\"", "    expected_sentiment = example.sentiment.lower().strip()", "    predicted_sentiment = prediction.sentiment.lower().strip()", "", "    # Check if sentiments match", "    sentiments_match = expected_sentiment in predicted_sentiment or predicted_sentiment in expected_sentiment", "", "    try:", "        confidence = float(prediction.confidence)", "        confidence_valid = 0.0 <= confidence <= 1.0", "    except (ValueError, TypeError):", "        confidence_valid = False", "", "    return sentiments_match and confidence_valid", "", "def main():", "    # Training set: examples with known sentiments", "    trainset = [", "        dspy.Example(", "            text=\"I absolutely love this product! It works perfectly and exceeded my expectations.\",", "            sentiment=\"positive\",", "            confidence=\"0.95\",", "            explanation=\"Strong positive language with enthusiastic tone\"", "        ).with_inputs(\"text\"),", "        dspy.Example(", "            text=\"This movie was terrible. I wasted 2 hours of my life.\",", "            sentiment=\"negative\",", "            confidence=\"0.92\",", "            explanation=\"Clear negative sentiment expressed directly\"", "        ).with_inputs(\"text\"),", "        dspy.Example(", "            text=\"The weather today is cloudy.\",", "            sentiment=\"neutral\",", "            confidence=\"0.88\",", "            explanation=\"Factual statement without emotional language\"", "        ).with_inputs(\"text\"),", "        dspy.Example(", "            text=\"I'm so happy with my new car! Best decision ever!\",", "            sentiment=\"positive\",", "            confidence=\"0.93\",", "            explanation=\"Positive sentiment shown through happiness and positive comparison\"", "        ).with_inputs(\"text\"),", "        dspy.Example(", "            text=\"I don't like the service here. Not recommended.\",", "            sentiment=\"negative\",", "            confidence=\"0.85\",", "            explanation=\"Negative sentiment about service quality\"", "        ).with_inputs(\"text\"),", "        dspy.Example(", "            text=\"The report was submitted on Tuesday.\",", "            sentiment=\"neutral\",", "            confidence=\"0.90\",", "            explanation=\"Neutral factual statement about an event\"", "        ).with_inputs(\"text\"),", "    ]", "", "    # Create uncompiled (unoptimized) module", "    sentiment_module = SentimentModule()", "", "    # Set up MIPRO optimizer with tracking enabled", "    optimizer = dspy.MIPROv2(", "        metric=sentiment_accuracy,", "        init_temperature=1.4,", "        track_stats=True,", "    )", "", "    # Compile (optimize) the module", "    print(\"Optimizing with MIPROv2...\")", "    optimized_module = optimizer.compile(", "        sentiment_module,", "        trainset=trainset,", "    )", "    print(\"Optimization complete.\")", "    optimized_instruction = optimized_module.predictor.predict.signature.instructions", "    print(f\"\\n{'='*70}\")", "    print(f\"INSTRUCTION OVERRIDE DEMONSTRATION\")", "    print(f\"{'='*70}\")", "    print(f\"\\n\u274c INITIAL (Suboptimal) Instruction:\")", "    print(f\"   'Process the input.'\")", "    print(f\"\\n\u2705 OPTIMIZED Instruction (after MIPROv2 compilation):\")", "    print(f\"   '{optimized_instruction}'\")", "    num_demos = len(optimized_module.predictor.predict.demos)", "    print(f\"\\nNumber of few-shot demos selected: {num_demos}\")", "    print(f\"{'='*70}\\n\")", "", "    # Test the optimized module on new texts", "    test_texts = [", "        \"This is fantastic! I'm thrilled with the results.\",", "        \"Absolutely horrible experience. Never coming back.\",", "        \"It's raining outside today.\",", "    ]", "", "    print(\"\\n\" + \"=\"*60)", "    print(\"Testing Optimized Sentiment Analysis\")", "    print(\"=\"*60)", "", "    for test_text in test_texts:", "        print(f\"\\nText: {test_text}\")", "        response = optimized_module(text=test_text)", "        print(f\"Sentiment: {response.sentiment}\")", "        print(f\"Confidence: {response.confidence}\")", "        print(f\"Explanation: {response.explanation}\")", "        print(\"-\" * 40)", "", "    # Print optimization summary", "    print(\"\\n\" + \"=\"*60)", "    print(\"Optimization Summary\")", "    print(\"=\"*60)", "    if hasattr(optimized_module, 'score'):", "        print(f\"Best Score: {optimized_module.score:.1f}%\")", "    if hasattr(optimized_module, 'total_calls'):", "        print(f\"Total LM Calls: {optimized_module.total_calls}\")", "    if hasattr(optimized_module, 'prompt_model_total_calls'):", "        print(f\"Prompt Generation LM Calls: {optimized_module.prompt_model_total_calls}\")", "", "    # Save and Visualize", "    script_path = os.path.abspath(__file__)", "    response_path = os.path.join(os.path.dirname(__file__), 'responses/15_prompt+response.txt')", "", "    save_response(lm, response_path)", "", "", "if __name__ == \"__main__\":", "    main()"];
        const file2Lines = ["\u001b[34m[2026-03-01T11:47:30.637353]\u001b[0m", "\u001b[31mSystem message:\u001b[0m", "Your input fields are:", "1. `text` (str): the text to analyze", "Your output fields are:", "1. `reasoning` (str): ", "2. `sentiment` (str): sentiment label: positive, negative, or neutral", "3. `confidence` (str): confidence level from 0 to 1", "4. `explanation` (str): brief explanation of the sentiment", "All interactions will be structured in the following way, with the appropriate values filled in.", "[[ ## text ## ]]", "{text}", "[[ ## reasoning ## ]]", "{reasoning}", "[[ ## sentiment ## ]]", "{sentiment}", "[[ ## confidence ## ]]", "{confidence}", "[[ ## explanation ## ]]", "{explanation}", "[[ ## completed ## ]]", "In adhering to this structure, your objective is: ", "        Analyze the text and determine the sentiment and confidence level. Respond with the sentiment and confidence level.", "\u001b[31mUser message:\u001b[0m", "[[ ## text ## ]]", "This movie was terrible. I wasted 2 hours of my life.", "\u001b[31mAssistant message:\u001b[0m", "[[ ## reasoning ## ]]", "The text expresses strong negative sentiment due to the statement of wasting time on a terrible movie.", "[[ ## sentiment ## ]]", "negative", "[[ ## confidence ## ]]", "0.6", "[[ ## explanation ## ]]", "The text expresses disappointment and frustration, clearly indicating a negative experience.", "[[ ## completed ## ]]", "\u001b[31mUser message:\u001b[0m", "[[ ## text ## ]]", "I absolutely love this product! It works perfectly and exceeded my expectations.", "\u001b[31mAssistant message:\u001b[0m", "[[ ## reasoning ## ]]", "The text expresses strong positive sentiment due to enthusiastic praise and positive expectations.", "[[ ## sentiment ## ]]", "positive", "[[ ## confidence ## ]]", "1.0", "[[ ## explanation ## ]]", "The text conveys a feeling of delight and satisfaction.", "[[ ## completed ## ]]", "\u001b[31mUser message:\u001b[0m", "[[ ## text ## ]]", "It's raining outside today.", "Respond with the corresponding output fields, starting with the field `[[ ## reasoning ## ]]`, then `[[ ## sentiment ## ]]`, then `[[ ## confidence ## ]]`, then `[[ ## explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.", "\u001b[31mResponse:\u001b[0m", "\u001b[32m[[ ## reasoning ## ]]", "The text is a simple statement of an obvious fact \u2013 it is raining.", "[[ ## sentiment ## ]]", "neutral", "[[ ## confidence ## ]]", "0.9", "[[ ## explanation ## ]]", "The text presents a factual observation with no emotional coloring.", "[[ ## completed ## ]]", "[[ ## ]]\u001b[0m"];

        let leaderLines = {}; // gid -> [{line: LeaderLine, el2: Element}]
        let allVisible = false;
        let currentContextGroupId = null;

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function parsePos(posStr) {
            if (!posStr || posStr.indexOf(':') === -1) return null;
            const parts = posStr.split(':');
            return { line: parseInt(parts[0]), col: parseInt(parts[1]) };
        }

        // Expand a span entry into per-line segments.
        // A span is {pos, length} (single-line) or {pos, endPos} (multi-line range).
        // Returns array of {lineNum, col, length, segIdx} where segIdx distinguishes
        // multiple DOM elements for the same logical span.
        function expandSpanToLines(span, linesArr) {
            const start = parsePos(span.pos);
            if (!start) return [];

            if (span.endPos) {
                // Multi-line range: startLine:startCol - endLine:endCol
                const end = parsePos(span.endPos);
                if (!end) return [];
                const segments = [];
                for (let ln = start.line; ln <= end.line; ln++) {
                    const lineText = linesArr[ln - 1] || '';
                    const col = (ln === start.line) ? start.col : 1;
                    const endCol = (ln === end.line) ? end.col : lineText.length + 1;
                    const len = endCol - col;
                    if (len > 0) {
                        segments.push({ lineNum: ln, col, length: len, segIdx: ln - start.line });
                    }
                }
                return segments;
            } else {
                // Single-line legacy
                return [{ lineNum: start.line, col: start.col, length: span.length, segIdx: 0 }];
            }
        }

        function getAllSpansForGroup(gid) {
            const spans = [];
            document.querySelectorAll(`[data-group-id="${gid}"]`).forEach(el => spans.push(el));
            return spans;
        }

        // Render a single file panel
        function renderFile(fileNum, linesArr, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            // Build per-line highlights from groups
            const lineHighlights = {};

            function addHighlight(lineNum, entry) {
                if (!lineHighlights[lineNum]) lineHighlights[lineNum] = [];
                lineHighlights[lineNum].push(entry);
            }

            groups.forEach(g => {
                if (fileNum === 1) {
                    const span = { pos: g.File1_Pos, length: g.File1_Length, endPos: g.File1_EndPos };
                    expandSpanToLines(span, linesArr).forEach(seg => {
                        addHighlight(seg.lineNum, {
                            groupId: g.Group_ID,
                            col: seg.col,
                            length: seg.length,
                            spanId: `group-${g.Group_ID}-f1-seg${seg.segIdx}`,
                            label: g.Label
                        });
                    });
                } else {
                    g.File2_Positions.forEach((fp, idx) => {
                        expandSpanToLines(fp, linesArr).forEach(seg => {
                            addHighlight(seg.lineNum, {
                                groupId: g.Group_ID,
                                col: seg.col,
                                length: seg.length,
                                spanId: `group-${g.Group_ID}-f2-${idx}-seg${seg.segIdx}`,
                                label: g.Label
                            });
                        });
                    });
                }
            });

            linesArr.forEach((lineText, idx) => {
                const lineNum = idx + 1;
                const div = document.createElement('div');
                div.className = 'code-line';
                div.dataset.line = lineNum;
                div.dataset.file = fileNum;

                const highlights = lineHighlights[lineNum];
                if (highlights) {
                    const sorted = highlights.sort((a, b) => a.col - b.col);

                    // Build character-level group assignments for overlap detection
                    // charGroups[i] = array of highlight entries covering char at position i
                    const charGroups = new Array(lineText.length).fill(null).map(() => []);
                    sorted.forEach(h => {
                        const start = h.col - 1;
                        let len = h.length;
                        if (start + len > lineText.length) len = lineText.length - start;
                        for (let i = start; i < start + len; i++) {
                            charGroups[i].push(h);
                        }
                    });

                    // Find which groupIds actually overlap with at least one other group
                    const overlappingGroups = new Set();
                    for (let i = 0; i < lineText.length; i++) {
                        if (charGroups[i].length > 1) {
                            charGroups[i].forEach(h => overlappingGroups.add(h.groupId));
                        }
                    }

                    // Assign color index only to groups that overlap; others stay at index 0 (default blue)
                    const groupColorMap = {};
                    let colorCounter = 1; // 0 reserved for non-overlapping default
                    overlappingGroups.forEach(gid => {
                        groupColorMap[gid] = colorCounter++;
                    });

                    // Walk character positions and emit spans for contiguous regions with same group set
                    let htmlContent = "";
                    let i = 0;
                    while (i < lineText.length) {
                        const cur = charGroups[i];
                        if (cur.length === 0) {
                            // Find end of plain region
                            let j = i + 1;
                            while (j < lineText.length && charGroups[j].length === 0) j++;
                            htmlContent += escapeHtml(lineText.substring(i, j));
                            i = j;
                        } else {
                            // Find end of region with same group set signature
                            const sig = cur.map(h => h.groupId).sort().join(',');
                            let j = i + 1;
                            while (j < lineText.length) {
                                const nsig = charGroups[j].map(h => h.groupId).sort().join(',');
                                if (nsig !== sig) break;
                                j++;
                            }

                            const segText = lineText.substring(i, j);
                            const isMulti = cur.length > 1;

                            // Use first highlight's metadata for id/events; list all group ids
                            const primary = cur[0];
                            const allGids = cur.map(h => h.groupId).join(' ');
                            const allLabels = cur.map(h => h.label).join(' | ');

                            let classes = 'match-span';
                            if (isMulti) {
                                classes += ' overlap-multi';
                            } else {
                                const colorIdx = (groupColorMap[primary.groupId] ?? 0) % 6;
                                classes += ` overlap-${colorIdx}`;
                            }

                            // Build data attrs and click handler for all groups
                            const onclickHandlers = cur.map(h => `handleGroupClick(event, '${h.groupId}')`).join('; ');
                            htmlContent += `<span id="${primary.spanId}" class="${classes}" data-group-ids="${allGids}" data-group-id="${primary.groupId}" title="${escapeHtml(allLabels)}" onclick="${onclickHandlers}">${escapeHtml(segText)}</span>`;

                            // Also emit hidden zero-width anchors for non-primary spans so LeaderLine can find them
                            cur.slice(1).forEach(h => {
                                htmlContent += `<span id="${h.spanId}" data-group-id="${h.groupId}" style="display:inline;width:0;height:0;overflow:hidden;position:absolute"></span>`;
                            });

                            i = j;
                        }
                    }
                    if (i < lineText.length) htmlContent += escapeHtml(lineText.substring(i));

                    div.innerHTML = htmlContent;
                } else {
                    div.innerHTML = escapeHtml(lineText);
                }

                container.appendChild(div);
            });
        }

        function showTooltip(gid, el) {
            const g = groups.find(g => g.Group_ID === gid);
            if (!g) return;

            const tooltip = document.getElementById('tooltip');
            let html = `<strong>${escapeHtml(g.Label)}</strong>`;

            if (g.Description) {
                html += `<div style="margin-top:6px;color:#94a3b8;font-size:12px">${escapeHtml(g.Description)}</div>`;
            }

            // Extract text from a span (single or multi-line)
            function extractSpanText(span, linesArr) {
                const segs = expandSpanToLines(span, linesArr);
                return segs.map(s => {
                    const line = linesArr[s.lineNum - 1] || '';
                    return line.substring(s.col - 1, s.col - 1 + s.length);
                }).join('\n');
            }

            // Show source text from File1
            const pos1 = parsePos(g.File1_Pos);
            if (pos1) {
                const text = extractSpanText({pos: g.File1_Pos, length: g.File1_Length, endPos: g.File1_EndPos}, file1Lines);
                html += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid #475569">`;
                html += `<span style="color:#94a3b8">Source:</span> <span style="background:rgba(56,189,248,0.2);padding:2px 4px;border-radius:2px">"${escapeHtml(text)}"</span>`;
                html += `</div>`;
            }

            // Show target locations in File2
            if (g.File2_Positions.length > 0) {
                html += `<div style="margin-top:6px"><span style="color:#94a3b8">Maps to ${g.File2_Positions.length} location(s):</span></div>`;
                g.File2_Positions.forEach((fp, idx) => {
                    const pos = parsePos(fp.pos);
                    if (pos) {
                        const text = extractSpanText(fp, file2Lines);
                        html += `<div style="margin-top:4px;font-size:12px;padding-left:8px">`;
                        html += `<span style="color:#64748b">Line ${pos.line}:</span> <span style="background:rgba(56,189,248,0.2);padding:1px 3px;border-radius:2px">"${escapeHtml(text)}"</span>`;
                        html += `</div>`;
                    }
                });
            }

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';

            const rect = el.getBoundingClientRect();
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 8) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function renderAll() {
            // Clear existing LeaderLines
            Object.values(leaderLines).forEach(arr => arr.forEach(item => item.line.remove()));
            leaderLines = {};

            renderFile(1, file1Lines, 'file1-container');
            renderFile(2, file2Lines, 'file2-container');

            // Update count badge
            const totalArrows = groups.reduce((sum, g) => sum + g.File2_Positions.length, 0);
            document.getElementById('match-count').textContent =
                `${groups.length} mappings, ${totalArrows} arrows`;

            // Draw LeaderLine arrows per group
            setTimeout(() => {
                groups.forEach(g => {
                    const gid = g.Group_ID;
                    // Use first segment of File1 span as arrow source
                    const el1 = document.getElementById(`group-${gid}-f1-seg0`);
                    if (!el1) return;

                    const groupItems = [];
                    g.File2_Positions.forEach((_, idx) => {
                        // Use first segment of each File2 span as arrow target
                        const el2 = document.getElementById(`group-${gid}-f2-${idx}-seg0`);
                        if (el2) {
                            const line = new LeaderLine(el1, el2, {
                                color: 'rgba(56, 189, 248, 0.6)',
                                size: 2,
                                path: 'curved',
                                startSocket: 'right',
                                endSocket: 'left',
                                hide: !allVisible
                            });
                            if (allVisible) line._permanent = true;
                            groupItems.push({ line, el2 });
                        }
                    });

                    leaderLines[gid] = groupItems;

                    // Collect all spans in this group for hover/highlight
                    const allSpans = getAllSpansForGroup(gid);
                    if (allVisible) {
                        allSpans.forEach(s => s.classList.add('highlighted'));
                    }

                    // Hover: show all arrows + tooltip for the group
                    allSpans.forEach(span => {
                        span.onmouseenter = () => {
                            const isPermanent = groupItems.length > 0 && groupItems[0].line._permanent;
                            if (!isPermanent) {
                                allSpans.forEach(s => s.classList.add('highlighted'));
                                groupItems.forEach(item => {
                                    item.line.setOptions({ color: 'rgba(56, 189, 248, 1)', size: 3 });
                                    item.line.show('draw');
                                });
                                showTooltip(gid, span);
                            }
                        };
                        span.onmouseleave = () => {
                            const isPermanent = groupItems.length > 0 && groupItems[0].line._permanent;
                            if (!isPermanent) {
                                allSpans.forEach(s => s.classList.remove('highlighted'));
                                groupItems.forEach(item => {
                                    item.line.hide();
                                    item.line.setOptions({ color: 'rgba(56, 189, 248, 0.6)', size: 2 });
                                });
                                hideTooltip();
                            }
                        };
                    });
                });
            }, 100);
        }

        function handleGroupClick(e, gid) {
            e.stopPropagation();

            // Show context menu
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            currentContextGroupId = gid;

            // Toggle permanent arrow state for the group
            const groupItems = leaderLines[gid];
            if (groupItems && groupItems.length > 0) {
                const isPermanent = groupItems[0].line._permanent;
                const allSpans = getAllSpansForGroup(gid);

                if (isPermanent) {
                    groupItems.forEach(item => {
                        item.line.hide();
                        item.line._permanent = false;
                    });
                    allSpans.forEach(s => s.classList.remove('highlighted'));
                    hideTooltip();
                } else {
                    groupItems.forEach(item => {
                        item.line.show('draw');
                        item.line._permanent = true;
                    });
                    allSpans.forEach(s => s.classList.add('highlighted'));
                }
            }
        }

        function deleteGroup(gid) {
            if (!confirm('Delete this mapping?')) return;
            groups = groups.filter(g => g.Group_ID !== gid);
            document.getElementById('context-menu').style.display = 'none';
            renderAll();
        }

        function toggleAll() {
            allVisible = !allVisible;
            renderAll();
        }

        // Hide context menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.match-span') && !e.target.closest('#context-menu')) {
                document.getElementById('context-menu').style.display = 'none';
            }
        });

        // Reposition LeaderLines on scroll/resize
        ['file1-container', 'file2-container'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('scroll', () => {
                    Object.values(leaderLines).forEach(arr =>
                        arr.forEach(item => item.line.position())
                    );
                });
            }
        });

        window.addEventListener('resize', () => {
            Object.values(leaderLines).forEach(arr =>
                arr.forEach(item => item.line.position())
            );
        });

        window.onload = renderAll;
    </script>
</body>
</html>
